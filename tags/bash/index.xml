<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bash on Personal Blog</title>
    <link>http://localhost:1313/blog/tags/bash/</link>
    <description>Recent content in Bash on Personal Blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 18 Oct 2012 02:03:52 +0000</lastBuildDate>
    <atom:link href="http://localhost:1313/blog/tags/bash/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Script para grabar la consola en un .gif animado</title>
      <link>http://localhost:1313/blog/posts/script-para-grabar-la-consola-en-un-gif-animado/</link>
      <pubDate>Thu, 18 Oct 2012 02:03:52 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/posts/script-para-grabar-la-consola-en-un-gif-animado/</guid>
      <description>&lt;p&gt;Hoy me surgió una necesidad, que me pareció bastante simple pero no encontré herramientas simples que me lo solucionaran. Les dejo este script, que graba un gif de la consola durante X segundos (idea de @shinax y @rootmyword). Ese valor se lo pasamos por parámetro (no lo valido ni tiene default, porque la vida es demasiado corta para controlarlo) . Hay que correr el script con un &amp;amp; al final de la línea, asi pasa a correr en background y podemos usar la consola.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/bin/bash
clear
mkdir temp_gif

segs=`expr $1 \* 5`

for (( i = 1; i &amp;lt;= $segs ; i++ ));
do
    printf -v number &amp;quot;%06d&amp;quot; $i
    import -window $WINDOWID temp_gif/$number.gif 
    sleep 0.2
done

convert -delay 20 -loop 0 temp_gif/*.gif animacion.gif

rm -R temp_gif
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El código terminó siendo más simple de lo que pensaba, toda la magia la hace &lt;strong&gt;ImageMagick&lt;/strong&gt;. Explico por línea, porque la idea siempre es aprender como funciona:
Línea 5. Toma el primer parámetro que le demos, lo multiplica por 5 porque cada imagen la saco cada 0.2 segundos ;)
Línea 9. El &lt;strong&gt;printf&lt;/strong&gt; lo utilizo para formatear &amp;i;, neceito hacer un zero-padding, o sea, rellenar con ceros a la izquierda, para que después el conversor me tome el orden correcto. El parámetro -v indica que no lo imprima, sino que lo almacene en una variable.
Línea 10. ImageMagick se encarga de guardar la imágen de la ventana que le digo, para $WINDOWSID creo que es necesario &lt;strong&gt;xorg-xwininfo&lt;/strong&gt;, ya lo tenía instalado.
Línea 13. Toma todas las imágenes de la carpeta, las concatena con un delay de 0.2 segundos y hace un loop infinito.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Comando at, automatizar scripts sin usar crontab</title>
      <link>http://localhost:1313/blog/posts/comando-at-automatizar-scripts-sin-usar-crontab/</link>
      <pubDate>Mon, 23 Jan 2012 16:34:56 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/posts/comando-at-automatizar-scripts-sin-usar-crontab/</guid>
      <description>&lt;p&gt;A diferencia de &lt;strong&gt;cron&lt;/strong&gt;, &lt;strong&gt;at&lt;/strong&gt; permite programar un comando/script para que sea ejecutado sólo una vez y no periodicamente.&lt;/p&gt;

&lt;p&gt;Antes que nada deben instalarlo, no suele venir en las distribuciones por defecto. Usen pacman, aptitude, yum o lo que sea, tiene que estar en los repositorios.
Una vez instalado, deben correr el servicio y por que no agregarlo en el /etc/rc.conf para que arranque solo. Si no hacen esto no van a correrse los scripts.&lt;/p&gt;

&lt;p&gt;Para utilizarlo tenemos varias alternativas, la primera es &lt;em&gt;especificarle la fecha y hora&lt;/em&gt;, luego escribir el script (es importante que una vez que terminemos, presionemos Control+D):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;at 10:31am Jan 23 
warning: commands will be executed using /bin/sh
at&amp;gt; yaourt -Syu      
at&amp;gt; (Control +D) &amp;lt;eot&amp;gt;
job 5 at Mon Jan 23 10:31:00 2012
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;También acepta otros &lt;em&gt;formatos&lt;/em&gt; de fechas, por ejemplo, para ejecutar algo mañana a esta misma hora, sería&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;at now tomorrow
at&amp;gt; blah blah
at&amp;gt; meh
at&amp;gt; (Control +D) &amp;lt;eot&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para mostrar los comandos que están en cola de ejecución, basta con hacer &lt;strong&gt;at -l&lt;/strong&gt; o &lt;strong&gt;atq&lt;/strong&gt;, esto nos traerá un id, la fecha/hora en la que se ejecuta y el usuario que lo creó.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;at -l
6   Mon Jan 23 11:41:00 2012 a xebuz
7   Wed Jan 25 00:01:00 2012 a xebuz
5   Mon Jan 23 10:31:00 2012 a xebuz
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Para cancelar o eliminar una tarea pendiente, se utiliza &lt;strong&gt;atrm&lt;/strong&gt; o &lt;strong&gt;at -r&lt;/strong&gt; o &lt;strong&gt;at -d&lt;/strong&gt; :P, seguida del id de la tarea (obtenida desde el comando anterior).
Por último, si quieren ver todo el contenido del script, con &lt;strong&gt;at -c &lt;em&gt;id&lt;/em&gt;&lt;/strong&gt; lo obtienen completo.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Z Bash, o zsh, una shell con Z de &#34;ZOMG que buena shell&#34;</title>
      <link>http://localhost:1313/blog/posts/zsh/</link>
      <pubDate>Thu, 20 Oct 2011 18:26:48 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/posts/zsh/</guid>
      <description>&lt;p&gt;&lt;strong&gt;Z Bash&lt;/strong&gt;, o mejor &lt;strong&gt;zsh&lt;/strong&gt;, es un interprete de comándos (&lt;em&gt;shell&lt;/em&gt;), excelente alternativa al Bash que viene por defecto (&lt;em&gt;Bourne-again Shell&lt;/em&gt;). Como mejoras, se destaca:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Mejorado en el autocompletado.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Muy customizable.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Corrección de tipeo.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Mejor manejo de funciones.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Es una shell mas hipster (?)._ (En realidad no, tiene mas de 20 años, y se usa bastante&amp;hellip;pero no viene por defecto)_&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;La instalación es simple, son unos poco kilobytes y seguro esta disponible en la distro que usen. En mi caso basta con:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;pacman -S zsh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Una vez instalada, debería figurar en el archivo /etc/shells, para setearla como shell por defecto tenemos que correr:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;chsh -s $(which zsh)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;La primera vez que ingresan, la shell les sugiere que ejecuten &lt;strong&gt;zsh-newuser-install&lt;/strong&gt;, lo cual es recomendable, da una pequeña pero útil instroducción, con asistentes de configuración.&lt;/p&gt;

&lt;p&gt;Ahora sí, veamos algunas cosas que tiene para ofrecernos&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Autocompletado de parametros&lt;/strong&gt;
Antes pensaba que bash era buena con el autocompletado, claro que viniendo del cmd de Windows cualquier cosa es mejor; zsh vino a abrir una nueva puerta a la comodidad en la línea de comandos.
Es rápidisimo y funciona con todos* los comandos, sólo pongan el - y para que liste las opciones.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Historial de bash, compatible con zsh&lt;/strong&gt;
Una de las primeras cosas que necesité migrando de shell fue el historial. Pueden copiar &lt;em&gt;~/.bash_history _a _~/.histfile&lt;/em&gt; y van a tener lo mismo que bash, imprescindible si usan &lt;strong&gt;Control + R&lt;/strong&gt;.
Tambien es compatible el archivo &lt;em&gt;~/.bashrc _con el _~/.zshrc&lt;/em&gt; y el_ ~/.bash&lt;em&gt;profile&lt;/em&gt; con &lt;em&gt;~/.zprofile&lt;/em&gt;, pero en mi caso preferí hacer copias a mano de lo que necesitaba. Sólo cuestión de gustos.
Además, permite compartir el historial entre sesiones, muy comodo si entramos desde ssh y localmente a una PC.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;zsh-yaourt&lt;/strong&gt;
Este paquete está en el AUR, y si, adivinaron, agrega autocompletado de paquetes a yaourt, es increiblemente útil, a lo _apt-get _si quieren una comparación, es muy bueno y rápido.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Paginador &amp;lsquo;inteligente&amp;rsquo;&lt;/strong&gt;
No se si Paginador es la palabra apropiada, tampoco se si inteligente sería el adjetivo indicador. Todos somos unos vagos, por eso usamos la terminal, que mejor que escribir cat LEAME, cat LEAME | less, si, escribir solo LEAME, bueno, zsh nos entiende, así que funciona así.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Diferentes &amp;ldquo;key bindings&amp;rdquo;&lt;/strong&gt;
En este caso, zsh los meneja de otra forma, y es frustrante mover las fechas de dirección y no obtener lo que pretendemos. No me resultó cómodo (porque no le dí tiempo a ver como funcionaba, ya estoy viejo para algunas cosas). Para dejarlo funcionando &amp;ldquo;a lo Bash&amp;rdquo;, tienen que editar el archivo &lt;em&gt;~/.zshrc&lt;/em&gt;
[spoiler title=&amp;ldquo;Agregar estas líneas&amp;rdquo;]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bindkey &amp;quot;e[1~&amp;quot; beginning-of-line # Home
bindkey &amp;quot;e[4~&amp;quot; end-of-line # End
bindkey &amp;quot;e[5~&amp;quot; beginning-of-history # PageUp
bindkey &amp;quot;e[6~&amp;quot; end-of-history # PageDown
bindkey &amp;quot;e[2~&amp;quot; quoted-insert # Ins
bindkey &amp;quot;e[3~&amp;quot; delete-char # Del
bindkey &amp;quot;e[5C&amp;quot; forward-word
bindkey &amp;quot;eOc&amp;quot; emacs-forward-word
bindkey &amp;quot;e[5D&amp;quot; backward-word
bindkey &amp;quot;eOd&amp;quot; emacs-backward-word
bindkey &amp;quot;ee[C&amp;quot; forward-word
bindkey &amp;quot;ee[D&amp;quot; backward-word
bindkey &amp;quot;e[Z&amp;quot; reverse-menu-complete # Shift+Tab
# for rxvt
bindkey &amp;quot;e[7~&amp;quot; beginning-of-line # Home
bindkey &amp;quot;e[8~&amp;quot; end-of-line # End
# for non RH/Debian xterm, can&#39;t hurt for RH/Debian xterm
bindkey &amp;quot;eOH&amp;quot; beginning-of-line
bindkey &amp;quot;eOF&amp;quot; end-of-line
# for freebsd console
bindkey &amp;quot;e[H&amp;quot; beginning-of-line
bindkey &amp;quot;e[F&amp;quot; end-of-line
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[/spoiler]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Correccion de typos&lt;/strong&gt;
Para los dislexicos como uno, esto es muy bueno, nos autocorrige directorios, comandos, archivos&amp;hellip; probandolo es muy bueno, no perfecto, pero ayuda a la hora de escribir rapido.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Links recomendados y fuentes para el post&lt;/strong&gt;
&lt;a href=&#34;http://zsh.sourceforge.net/Guide/zshguide.html&#34;&gt;Guía oficial (en inglés)&lt;/a&gt;
&lt;a href=&#34;https://wiki.archlinux.org/index.php/Zsh&#34;&gt;Wiki de Zsh, para Arch&lt;/a&gt;
&lt;a href=&#34;http://pwet.fr/man/linux/commandes/zsh_lovers&#34;&gt;zhs-lovers&lt;/a&gt;
&lt;a href=&#34;http://zshwiki.org/home/start&#34;&gt;Una wiki muy completa&lt;/a&gt;
&lt;a href=&#34;http://fausto23.wordpress.com/2010/01/31/zsh-esa-shell/&#34;&gt;Buena info para el .zshrc, en español&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;*Quizas no todos&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Big Brother is watching you. Monitorear usuarios en Linux.</title>
      <link>http://localhost:1313/blog/posts/big-brother-is-watching-you-monitorear-usuarios-en-linux/</link>
      <pubDate>Sun, 25 Sep 2011 16:18:50 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/posts/big-brother-is-watching-you-monitorear-usuarios-en-linux/</guid>
      <description>&lt;p&gt;Mantener un sistema estable a veces requiere observar que estan haciendo los usuarios.
No significa que tengamos que ponernos la gorra del Partido y salir a perseguir a Emmanuel Goldstein, sino sólo controlar un poco los recursos, evitando picos altos que puedan provocarnos inestabilidad.
Acá les dejo un par de comandos o de aplicaciones que tienen este propósito, espero que alguna les sirva&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;who&lt;/strong&gt;
El más simple, devuelve una lista de usuarios loggeados, y la tty donde están.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;w&lt;/strong&gt;
Similar a who, pero en este caso da un poco mas de información (no demasiada). Lista usuario, tty, tiempo loggeado, carga del sistema general y del usuario y que esta haciendo en ese momento. Un comando rápido, fácil y útil.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;whowatch&lt;/strong&gt;
Una aplicación bastante útil, crea un árbol con los usuarios loggeados, y
Con_ control + k_ mandamos un SIGKILL, con c switcheamos entre &amp;ldquo;comando/nombre de aplicacion&amp;rdquo;, la &lt;em&gt;o&lt;/em&gt; nos muestra el owner.
Pueden bajarla desde aca &lt;a href=&#34;http://wizard.ae.krakow.pl/~mike/&#34;&gt;http://wizard.ae.krakow.pl/~mike/&lt;/a&gt; aunque segurmente esté el los repositorios de la distro que usen.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;last&lt;/strong&gt; y &lt;strong&gt;lastlog&lt;/strong&gt;
Muestra el ultimo acceso de los usuarios, el segundo es el mas simple y cómodo para leer, lista los usuarios, tty, desde donde y fecha y hora del acceso.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;psacct&lt;/strong&gt;
Este es un conjunto de aplicaciones, muy utiles (informacion detallada &lt;a href=&#34;http://generationip.com/documentation/system-documentation/113-howto-on-psacct-for-a-complete-monitoring-of-processus-and-users-activities-on-your-system&#34;&gt;aca&lt;/a&gt;), dentro de las cuales se encuentra:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;ac&lt;/em&gt;: Muestra informacion acerca de cuanto tiempo estuvo loggeado el usuario.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;lastcomm&lt;/em&gt;: Información sobre el ultimo comando ejecutado.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;sa&lt;/em&gt;: Informacion sumarizada con los datos del comando anterior.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;last y lastb&lt;/em&gt;: Funciona muy similar al comando nombrado anteriormente, pero el segundo muestra tambien accesos fallidos.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Tips Linuxeros: Alias para Todos</title>
      <link>http://localhost:1313/blog/posts/tips-para-linux-alias-para-todos/</link>
      <pubDate>Fri, 02 Sep 2011 21:33:09 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/posts/tips-para-linux-alias-para-todos/</guid>
      <description>&lt;p&gt;Los alias en Linux son shortcuts o &lt;em&gt;sinónimos&lt;/em&gt; que podemos emplear para ejecutar comandos en la terminal.
Son muy útiles para correr comandos largos o simplemente crear nombres mas amigables, para algún comando que nos resulte deficil de recordar o a los que usemos mas seguido.
Para crearlos debemos escribir en el archivo &lt;strong&gt;~.bashrc&lt;/strong&gt; para dejarlos disponibles al usuario, o en /etc/bash.bashrc para dejarlos disponibles en todo el sistema.&lt;/p&gt;

&lt;p&gt;Las sintaxis es muy sencilla: &lt;em&gt;alias nombre=&amp;lsquo;comando&amp;rsquo;&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Algunos ejemplos&amp;hellip;&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#Gestión rapida de paquetería
alias instalar=&#39;sudo apt-get install&#39;
alias clearcache=&#39;yaourt -Scc&#39;
alias update=&#39;emerge --update --deep&#39;

#Vaciado de archivos
alias empty=&#39;:&amp;gt; $1&#39;

#Copiado con barra de progreso, velocidad y estadísticas
alias copy=&#39;rsync -avz --stats --progress&#39;

#Compartir la carpeta, via HTTP (http://127.0.0.1:8000)
alias sharehttp=&#39;python -m SimpleHTTPServer&#39;

#Mostrar unidades montadas, en columnas
alias mountt=&#39;mount | column -t&#39;

#Mostrar top 10 deprocesos que consuman mas memoria
alias pstop=&#39;ps aux | sort -nk +4 | tail&#39;

#Buscar proceso
alias psx=&#39;ps aux | grep &#39;

#Me olvide de poner sudo en el comando anterior
alias grrrrrrr=&#39;sudo !!&#39;

#Listar los puertos abiertos
alias openports=&#39;netstat --all --numeric --programs --inet&#39;

# Tambien podemos modificar el prompt o la terminal
# Agregandole la hora
alias hora=&#39;export PS1=&amp;quot;${PS1%\$*}&amp;quot;&#39; t $ &#39;
# o mejor aun, poniendola en la parte superior
alias horasuperior=&#39;while sleep 1;do tput sc;tput cup 0 $(($(tput cols)-29));date;tput rc;done &amp;amp;&#39;

#Alias con parametros (en realidad es una funcion)
#Crear un directorio y posicionarnos sobre el mismo
MKdir() { mkdir $1 &amp;amp;&amp;amp; cd $1 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Hacer los comandos &amp;ldquo;human-readeable&amp;rdquo; por defecto&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias ls=&#39;ls -h&#39;
alias du=&#39;du -h&#39;
alias df=-df -h&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;Simplificar los parámetros&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;alias ls=&#39;ls -hF --color=always&#39;
alias lr=&#39;ls -hR&#39;                    # recursive ls
alias ll=&#39;ls -hl&#39;
alias la=&#39;ll -hA&#39;
alias lx=&#39;ll -hBX&#39;                   # sort by extension
alias lz=&#39;ll -hrS&#39;                   # sort by size
alias lt=&#39;ll -rt&#39;                    # sort by date
alias lm=&#39;la | more&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;strong&gt;También podemos crear alias que solo funcionen para usuarios con privilegios de root&lt;/strong&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;if [ $UID -ne 0 ]; then
    alias scat=&#39;sudo cat&#39;
    alias svim=&#39;sudo vim&#39;
    alias root=&#39;sudo su&#39;
    alias reboot=&#39;sudo reboot&#39;
    alias halt=&#39;sudo halt&#39;
    alias netcfg=&#39;sudo netcfg2&#39;
fi
&lt;/code&gt;&lt;/pre&gt;

&lt;!-- more --&gt;

&lt;p&gt;Si queren saber cuales son los comandos que más se utilizan en el sistema, como para ver si pueden agilizar creando alias mas cortos, pueden correr esto:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; history | awk &#39;{print $2}&#39; | awk &#39;BEGIN {FS=&amp;quot;|&amp;quot;}{print $1}&#39; | sort | uniq -c | sort -n | tail -n 20 | sort -nr
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;[quote style=&amp;ldquo;1&amp;rdquo;] See, you not only have to be a good coder to create a system like Linux, you have to be a sneaky bastard too ;-) [/quote]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;em&gt;Linus Torvalds&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Tips Linuxeros: Manejo del historial</title>
      <link>http://localhost:1313/blog/posts/tips-para-linux-manejo-del-historial/</link>
      <pubDate>Fri, 22 Jul 2011 00:16:16 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/posts/tips-para-linux-manejo-del-historial/</guid>
      <description>&lt;p&gt;Quizás una de las mejores funcionalidades en la terminal de Linux, o por lo menos una de las más productivas, es la capacidad de generar un historial de lo que ejecutamos.
Ahora bien, existen varias formas de recorrerlo. La más común y la que seguramente todos usan, es mediante las flechas arriba y abajo, muy util, pero también existen otras formas de hacerlo :)&lt;/p&gt;

&lt;p&gt;Podemos hacer una búsqueda utilizando &lt;strong&gt;Ctrl+R&lt;/strong&gt; y el texto que deseamos. La búsqueda es incremental, en caso de que la primera opción no es la que queremos, sólo basta volver a presionar &lt;strong&gt;Ctrl+R&lt;/strong&gt;. Si queremos hacer la búsqueda en orden inverso, basta utilizar &lt;strong&gt;Ctrl+I&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Otra opción muy interesante es volver a ejecutar el comando anterior con &lt;strong&gt;!!&lt;/strong&gt; (doble signo de admiración). Es genial si nos olvidamos de ejecutar algo con permisos de superuser:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; sudo !!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;También se puede utilizar el &lt;strong&gt;!foo&lt;/strong&gt; para repetir la última vez que usamos foo, o &lt;strong&gt;!?foo&lt;/strong&gt; para volver a ejecutar el ultimo comando &lt;em&gt;que contenga&lt;/em&gt; foo.&lt;/p&gt;

&lt;p&gt;En caso de que querramos &lt;em&gt;reemplazar&lt;/em&gt; parte del script ejectutado anteriormente, por ejemplo, abrimos un archivo con nano pero ahora queremos abrirlo con vi, podemos correr&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;^nano^vi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;En caso de que necesitemos mostrar todos los comandos que contengan cierto termino basta con hacer un &lt;strong&gt;grep&lt;/strong&gt; de lo que devuelve el comando history:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; history | grep foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;El número de la izquierda es el orden del comando, podemos correr esa linea usando &lt;strong&gt;!numero&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Un detalle&amp;hellip;&lt;/em&gt;
Es posible que si usan múltipes instancias de la terminal (desde tty, gnome-terminal, guake, yakuke, etc), no se guarde el historial, para esto  basta con editar el archivo &lt;strong&gt;~/.bashrc&lt;/strong&gt; de esta forma:
[sourcecode language=&amp;ldquo;bash&amp;rdquo;]
 unset HISTFILESIZE
 HISTSIZE=5000 # cantidad de registros que quieran guardar
 PROMPT_COMMAND=&amp;ldquo;history -a&amp;rdquo;
 export HISTSIZE PROMPT_COMMAND
[/sourcecode]&lt;/p&gt;

&lt;p&gt;Y correr una vez el siguiente comando&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; shopt -s histappend
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>Descargar La Venganza Será Terrible, via Bash</title>
      <link>http://localhost:1313/blog/posts/descargar-la-venganza-sera-terrible-via-bash/</link>
      <pubDate>Thu, 21 Jul 2011 02:31:17 +0000</pubDate>
      
      <guid>http://localhost:1313/blog/posts/descargar-la-venganza-sera-terrible-via-bash/</guid>
      <description>

&lt;p&gt;Este es un pequeño script que descarga (via wget) el programa La Venganza Sera Terrible de &lt;a href=&#34;http://www.alejandrodolina.com.ar/&#34;&gt;Alejando Dolina&lt;/a&gt;; utilizando los archivos que genera a diario el sitio &lt;a href=&#34;http://venganzasdelpasado.com.ar/&#34;&gt;Venganzas del Pasado&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;[sourcecode language=&amp;ldquo;bash&amp;rdquo;]
#!/bin/bash&lt;/p&gt;

&lt;h1 id=&#34;medio-rustico-pero-si-lo-ejecuto-hoy:e7fb311ab5e08ba834ea459d13c1892b&#34;&gt;Medio rustico, pero si lo ejecuto hoy..&lt;/h1&gt;

&lt;h1 id=&#34;necesito-bajar-el-programa-de-anoche:e7fb311ab5e08ba834ea459d13c1892b&#34;&gt;necesito bajar el programa de anoche&lt;/h1&gt;

&lt;p&gt;day=&lt;code&gt;date +%d &#39;--date=-1 day&#39;&lt;/code&gt;
month=&lt;code&gt;date +%m &#39;--date=-1 day&#39;&lt;/code&gt;
year=&lt;code&gt;date +%Y &#39;--date=-1 day&#39;&lt;/code&gt;&lt;/p&gt;

&lt;h1 id=&#34;directorio-en-donde-se-guarda-el-archivo:e7fb311ab5e08ba834ea459d13c1892b&#34;&gt;Directorio en donde se guarda el archivo&lt;/h1&gt;

&lt;p&gt;folder=&amp;ldquo;$HOME/Dolina/&amp;rdquo;$year&amp;rdquo;/&amp;ldquo;$month&amp;rdquo;/&amp;rdquo;&lt;/p&gt;

&lt;p&gt;#Si lo ejecuto un lunes o un domingo, no hay nada para bajar
if [ &lt;code&gt;date +%u&lt;/code&gt; = 1 ] || [ &lt;code&gt;date +%u&lt;/code&gt; = 7 ]; then
echo &amp;ldquo;Anoche no hubo programa&amp;rdquo;
else
wget -q -w 600 -P $folder &amp;ldquo;&lt;a href=&#34;http://venganzasdelpasado.com.ar/&amp;quot;$year&amp;quot;/lavenganza_&amp;quot;$year&amp;quot;-&amp;quot;$month&amp;quot;-&amp;quot;$day&amp;quot;.mp3&amp;quot;&#34;&gt;http://venganzasdelpasado.com.ar/&amp;quot;$year&amp;quot;/lavenganza_&amp;quot;$year&amp;quot;-&amp;quot;$month&amp;quot;-&amp;quot;$day&amp;quot;.mp3&amp;quot;&lt;/a&gt;
fi
[/sourcecode]&lt;/p&gt;

&lt;p&gt;Yo lo tengo corriendo con crontab, a las 5 madrugada, cosa de que al levantarme ya lo haya bajado :)
Así como esta deberia funcionar solo en Linux, estaba haciendo algo con wxWidgets para jugar un rato con eso, que deberia ser multiplataforma, despues (o sea, cuando funcione) lo subo.&lt;/p&gt;

&lt;p&gt;Disponible en &lt;a href=&#34;https://gist.github.com/1079511&#34;&gt;Github&lt;/a&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>